# 실행될 서비스(컨테이너)들 정의
services:
  # 1. PostgreSQL + PostGIS 데이터베이스 서비스
  db:
    image: postgis/postgis:16-3.4-alpine
    container_name: r3_postgres_db
    environment:
      - POSTGRES_USER=r3user
      - POSTGRES_PASSWORD=r3password
      - POSTGRES_DB=r3db
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    restart: unless-stopped
    # ----> 1. 아래 healthcheck 부분을 통째로 추가합니다. <----
    # 이 설정은 5초마다 데이터베이스가 준비되었는지 확인합니다.
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U r3user -d r3db" ]
      interval: 5s
      timeout: 5s
      retries: 5

  # 2. Redis 캐시/메시지 브로커 서비스
  redis:
    image: redis:7-alpine
    container_name: r3_redis
    ports:
      - "6379:6379"
    restart: unless-stopped

  # 3. FastAPI 백엔드 API 서비스
  api:
    container_name: r3_api
    # 현재 디렉토리의 Dockerfile을 사용하여 이미지를 빌드합니다. (backend 루트 기준)
    build: .
    command: poetry run uvicorn app.main:app --host 0.0.0.0 --port 8000 --reload
    volumes:
      # 현재 폴더(backend)를 컨테이너의 /app 폴더와 동기화하여 코드 변경 즉시 반영
      - .:/app
      - /app/.venv
      # ✅ 미디어 영속화: 컨테이너의 /app/media ↔ 호스트 ./media
      - ./media:/app/media
    ports:
      - "8000:8000"
    # ✅ 환경변수는 .env 파일로 주입(루트/동일 위치 .env)
    env_file:
      - ./.env
    # db와 redis 서비스가 먼저 실행된 후에 api 서비스를 실행
    depends_on:
      db:
        condition: service_healthy # db 서비스가 'healthy' 상태가 될 때까지 기다립니다.
      redis:
        condition: service_started
    restart: unless-stopped

  # ----> 4. Alembic 마이그레이션 전용 서비스를 추가합니다. <----
  alembic:
    build: .
    # 이 서비스는 uvicorn을 실행하지 않고, 우리가 주는 명령만 기다립니다.
    command: tail -f /dev/null
    volumes:
      - .:/app
      - /app/.venv
      # (선택) Alembic 실행 중에도 media 접근이 필요하면 아래 주석 해제
      # - ./media:/app/media
    env_file:
      - ./.env
    depends_on:
      db:
        condition: service_healthy # db 서비스가 'healthy' 상태가 될 때까지 기다립니다.

# 데이터베이스 데이터를 영구적으로 보관하기 위한 볼륨 설정
volumes:
  postgres_data:
